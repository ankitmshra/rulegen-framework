import React, { useState, useEffect, useRef } from 'react';
import ReactMarkdown from 'react-markdown';
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';
import { vscDarkPlus } from 'react-syntax-highlighter/dist/esm/styles/prism';
import DownloadModal from './DownloadModal';
import { useNavigate } from 'react-router-dom';
import CodeBlockExportButton from './CodeBlockExportButton';
import ExportModal from './ExportModal';
import './codeblock.css';
import './form-elements.css';
import { AnimatePresence, motion } from 'framer-motion';

const RuleViewer = ({
  generatedPrompt,
  rules,
  currentRuleIndex,
  onRuleIndexChange,
  onGenerateRule,
  isGenerating,
  error,
  onBack,
  onPromptUpdate,
  workspace
}) => {
  const navigate = useNavigate();
  const [promptVisible, setPromptVisible] = useState(false);
  const [isEditingPrompt, setIsEditingPrompt] = useState(false);
  const [editedPrompt, setEditedPrompt] = useState(generatedPrompt);
  const [copySuccess, setCopySuccess] = useState('');
  const [showDownloadModal, setShowDownloadModal] = useState(false);
  const [copiedBlocks, setCopiedBlocks] = useState({});
  const [feedbackText, setFeedbackText] = useState('');
  const [selectedRules, setSelectedRules] = useState([]);
  const [showExportModal, setShowExportModal] = useState(false);

  // Update editedPrompt when generatedPrompt changes
  useEffect(() => {
    setEditedPrompt(generatedPrompt);
    
    // For debugging - log the first rule structure
    if (rules.length > 0) {
      console.log("Rule structure:", rules[0]);
    }
  }, [generatedPrompt, rules]);

  // Handle prompt edit save
  const handleSavePrompt = () => {
    if (onPromptUpdate) {
      onPromptUpdate(editedPrompt);
    }
    setIsEditingPrompt(false);
  };

  // Handle prompt edit cancel
  const handleCancelEdit = () => {
    setEditedPrompt(generatedPrompt);
    setIsEditingPrompt(false);
  };

  // Handle rule regeneration with feedback
  const handleRegenerateWithFeedback = () => {
    if (!feedbackText.trim()) return;

    // Make sure we're passing only the string, not any references to DOM elements
    const feedbackString = String(feedbackText.trim());

    // Call the rule generation function with feedback
    onGenerateRule(feedbackString);

    // Clear the feedback text
    setFeedbackText('');
  };

  // Copy rule to clipboard
  const copyToClipboard = () => {
    if (!rules[currentRuleIndex]?.rule) return;

    const textArea = document.createElement('textarea');
    textArea.value = rules[currentRuleIndex].rule;
    document.body.appendChild(textArea);
    textArea.select();

    try {
      const successful = document.execCommand('copy');
      setCopySuccess(successful ? 'Copied!' : 'Failed to copy');
    } catch (err) {
      setCopySuccess('Failed to copy');
    }

    document.body.removeChild(textArea);

    // Clear the "Copied!" message after 2 seconds
    setTimeout(() => {
      setCopySuccess('');
    }, 2000);
  };

  // Handle rule export
  const handleExportRule = (rule, codeBlockText) => {
    // Create a simple hash for the code block
    const hashCode = str => {
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32bit integer
      }
      return Math.abs(hash).toString(16);
    };
    
    const blockId = `${rule.id}-${hashCode(codeBlockText.substring(0, 50))}`;
    
    // Check if this specific code block is already selected
    if (selectedRules.some(r => r.blockId === blockId)) {
      setSelectedRules(selectedRules.filter(r => r.blockId !== blockId));
    } else {
      // Add this code block with its content to selected rules
      setSelectedRules([...selectedRules, {
        ...rule,
        blockId,
        codeBlockText,
        rule: `\`\`\`\n${codeBlockText}\n\`\`\``
      }]);
    }
  };

  // Download rule as .cf file
  const handleDownload = (filename) => {
    if (!rules[currentRuleIndex]?.rule) return;

    // Extract only the code blocks from the rule content
    const ruleContent = rules[currentRuleIndex].rule;
    const codeBlockRegex = /```(?:\w*\n)?([\s\S]*?)```/g;
    let match;
    let codeBlocks = [];

    // Find all code blocks
    while ((match = codeBlockRegex.exec(ruleContent)) !== null) {
      // The actual code content is in the first capturing group
      codeBlocks.push(match[1].trim());
    }

    // Combine all code blocks with proper spacing
    const combinedCode = codeBlocks.join('\n\n');

    // Add a header comment with attribution
    const header = `# SpamAssassin rules generated by Codex\n# Generated on: ${new Date().toISOString()}\n\n`;
    const fullContent = header + combinedCode;

    // Create a blob with only the extracted code content
    const blob = new Blob([fullContent], { type: 'text/plain' });

    // Create a temporary URL for the blob
    const url = URL.createObjectURL(blob);

    // Create a temporary link element
    const link = document.createElement('a');
    link.href = url;
    link.download = filename.endsWith('.cf') ? filename : `${filename}.cf`;

    // Append the link to the document, click it, and remove it
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    // Clean up the URL object
    URL.revokeObjectURL(url);

    // Close the modal
    setShowDownloadModal(false);
  };

  // Format date for display
  const formatDate = (dateString) => {
    const date = new Date(dateString);
    return date.toLocaleString();
  };

  // Get the current rule
  const currentRule = rules[currentRuleIndex] || {};
  const isRuleComplete = currentRule.is_complete;

  // Handle code block copy
  const handleCodeBlockCopy = (code) => {
    navigator.clipboard.writeText(code).then(() => {
      setCopySuccess('Copied!');
      setTimeout(() => {
        setCopySuccess('');
      }, 2000);
    }).catch(err => {
      console.error('Failed to copy: ', err);
    });
  };

  // Export all code blocks from current rule
  const handleExportAllCodeBlocks = () => {
    if (!currentRule?.rule) return;
    
    // Extract all code blocks from the rule content
    const ruleContent = currentRule.rule;
    const codeBlockRegex = /```(?:\w*\n)?([\s\S]*?)```/g;
    let match;
    let extractedCodeBlocks = [];
    
    // Find all code blocks
    while ((match = codeBlockRegex.exec(ruleContent)) !== null) {
      // The actual code content is in the first capturing group
      const codeBlockText = match[1].trim();
      
      // Create a simple hash for the code block
      const hashCode = str => {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
          const char = str.charCodeAt(i);
          hash = ((hash << 5) - hash) + char;
          hash = hash & hash; // Convert to 32bit integer
        }
        return Math.abs(hash).toString(16);
      };
      
      const blockId = `${currentRule.id}-${hashCode(codeBlockText.substring(0, 50))}`;
      
      // Add this code block to the list
      extractedCodeBlocks.push({
        ...currentRule,
        blockId,
        codeBlockText,
        rule: `\`\`\`\n${codeBlockText}\n\`\`\``,
        selected: true
      });
    }
    
    // Set the selected rules to all code blocks from current rule
    setSelectedRules(extractedCodeBlocks);
    
    // Open export modal if we found code blocks
    if (extractedCodeBlocks.length > 0) {
      setShowExportModal(true);
    }
  };

  // Custom renderer for code blocks with copy button
  const CodeBlock = ({ language, value }) => {
    // Get the current rule for export
    const currentRule = rules[currentRuleIndex] || {};
    
    // Create a simple hash for the code block
    const hashCode = str => {
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32bit integer
      }
      return Math.abs(hash).toString(16);
    };
    
    // Generate a unique ID for this code block
    const blockId = `${currentRule.id}-${hashCode(value.substring(0, 50))}`;
    
    // Check if this specific block is selected
    const isSelected = selectedRules.some(r => r.blockId === blockId);
    
    // Mark if this rule is selected for export
    const blockWithSelection = {
      ...currentRule,
      blockId,
      selected: isSelected
    };
    
    return (
      <div className="code-block-container">
        <button
          onClick={() => handleCodeBlockCopy(value)}
          className="copy-button"
          aria-label="Copy code"
          title="Copy code"
        >
          <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
          </svg>
        </button>
        {currentRule.is_complete && !error && (
          <CodeBlockExportButton 
            rule={blockWithSelection} 
            onExport={() => handleExportRule(currentRule, value)}
          />
        )}
        <SyntaxHighlighter
          language={language}
          style={vscDarkPlus}
          showLineNumbers={false}
          wrapLines={true}
          wrapLongLines={true}
          customStyle={{
            backgroundColor: '#f1f5f9',
            padding: '0.75rem',
            paddingBottom: '0.25rem',
            borderRadius: '0.375rem',
            fontSize: '0.875rem',
            color: '#334155',
            margin: 0
          }}
          codeTagProps={{
            style: {
              fontFamily: 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace',
              wordBreak: 'break-word',
              whiteSpace: 'pre-wrap'
            }
          }}
        >
          {value}
        </SyntaxHighlighter>
      </div>
    );
  };

  // Function to render markdown content with custom components
  const renderMarkdown = (content) => {
    return (
      <div className="markdown-content">
        <ReactMarkdown
          children={content}
          components={{
            code({ node, inline, className, children, ...props }) {
              if (inline) {
                return <code className="inline-code" {...props}>{children}</code>;
              }
              const match = /language-(\w+)/.exec(className || '');
              const language = match ? match[1] : '';
              const value = String(children).replace(/\n$/, '');
              return <CodeBlock language={language} value={value} />;
            },
            h1: ({ node, ...props }) => <h1 className="text-2xl font-bold mt-6 mb-3" {...props} />,
            h2: ({ node, ...props }) => <h2 className="text-xl font-bold mt-5 mb-2" {...props} />,
            h3: ({ node, ...props }) => <h3 className="text-lg font-bold mt-4 mb-2" {...props} />,
            h4: ({ node, ...props }) => <h4 className="text-base font-bold mt-3 mb-1" {...props} />,
            p: ({ node, ...props }) => <p className="my-2" {...props} />,
            ul: ({ node, ...props }) => <ul className="list-disc pl-5 my-2" {...props} />,
            ol: ({ node, ...props }) => <ol className="list-decimal pl-5 my-2" {...props} />,
            li: ({ node, ...props }) => <li className="my-1" {...props} />,
            blockquote: ({ node, ...props }) => (
              <blockquote className="border-l-4 border-gray-300 pl-4 my-2 italic" {...props} />
            ),
            hr: ({ node, ...props }) => <hr className="my-4 border-gray-300" {...props} />,
            table: ({ node, ...props }) => (
              <div className="overflow-x-auto">
                <table className="min-w-full divide-y divide-gray-300" {...props} />
              </div>
            ),
            th: ({ node, ...props }) => (
              <th className="px-4 py-2 bg-gray-100 font-semibold text-left" {...props} />
            ),
            td: ({ node, ...props }) => <td className="px-4 py-2 border-t" {...props} />,
          }}
        />
      </div>
    );
  };

  return (
    <div className="px-6 py-5">
      <h3 className="text-lg font-medium text-gray-900 mb-2">Generated Rule</h3>
      <p className="text-sm text-gray-500 mb-6">
        Review and manage generated SpamAssassin rules.
      </p>

      {error && (
        <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative mb-6" role="alert">
          <div className="flex items-center">
            <svg className="h-5 w-5 text-red-500 mr-2" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
              <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
            </svg>
            <span className="block sm:inline">{error}</span>
          </div>
        </div>
      )}

      <div className="bg-white shadow overflow-hidden rounded-lg mb-6">
        <div className="px-4 py-5 sm:px-6 border-b border-gray-200 flex justify-between items-center">
          <div>
            <h3 className="text-lg leading-6 font-medium text-gray-900">
              {rules.length > 0
                ? `Rule ${rules.length - currentRuleIndex}/${rules.length}`
                : 'No Rules Generated'}
            </h3>
            {currentRule.created_at && (
              <div className="mt-1 max-w-2xl text-sm text-gray-500">
                <p>Generated: {formatDate(currentRule.created_at)}</p>
                {currentRule.user && (
                  <p>Initiated by: {currentRule.user}</p>
                )}
                {currentRule.is_regeneration && (
                  <p className="text-indigo-600">Regenerated rule</p>
                )}
              </div>
            )}
          </div>

          <div className="flex space-x-2">
            <button
              onClick={() => setPromptVisible(!promptVisible)}
              className="inline-flex items-center px-3 py-2 border border-gray-300 shadow-sm text-sm leading-4 font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
            >
              <motion.span 
                initial={false}
                animate={{ rotate: promptVisible ? 180 : 0 }}
                transition={{ duration: 0.3 }}
                className="mr-2"
              >
                <svg className="h-4 w-4 text-gray-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
                </svg>
              </motion.span>
              {promptVisible ? 'Hide Prompt' : 'Show Prompt'}
            </button>

            {rules.length > 0 && isRuleComplete && !error && (
              <>
                <div className="flex-grow"></div>

                <button
                  onClick={() => selectedRules.length > 0 ? setShowExportModal(true) : null}
                  className={`
                    inline-flex items-center px-3 py-2 border shadow-sm text-sm leading-4 font-medium rounded-md
                    ${selectedRules.length > 0 
                      ? 'text-white bg-indigo-600 hover:bg-indigo-700 border-transparent' 
                      : 'text-gray-400 bg-gray-100 border-gray-200 cursor-not-allowed'
                    }
                    focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500
                    relative group
                  `}
                >
                  <svg className="-ml-0.5 mr-2 h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 10v6m0 0l-3-3m3 3l3-3m-3-3V4" />
                  </svg>
                  Export {selectedRules.length > 0 ? `${selectedRules.length} ${selectedRules.length === 1 ? 'Block' : 'Blocks'}` : 'Rules'}
                  
                  {/* Tooltip that appears on hover when no rules are selected */}
                  {selectedRules.length === 0 && (
                    <div className="absolute left-1/2 transform -translate-x-1/2 top-full mt-2 px-4 py-3 bg-white text-gray-700 text-xs rounded opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none z-50 shadow-lg border border-gray-200 text-center">
                      <div className="font-medium">Export rules to download</div>
                      <div className="absolute -top-2 left-1/2 transform -translate-x-1/2 w-3 h-3 bg-white rotate-45 border-t border-l border-gray-200"></div>
                    </div>
                  )}
                </button>
              </>
            )}
          </div>
        </div>

        {/* Prompt Collapsible Section */}
        <AnimatePresence initial={false}>
          {promptVisible && (
            <motion.div 
              initial={{ height: 0, opacity: 0 }}
              animate={{ height: "auto", opacity: 1 }}
              exit={{ height: 0, opacity: 0 }}
              transition={{ duration: 0.3, ease: "easeInOut" }}
              className="overflow-hidden border-b border-gray-200"
            >
              <div className="px-4 py-5 sm:p-6">
                <div className="flex justify-between items-center mb-3">
                  <h4 className="text-sm font-medium text-gray-900">Generated Prompt</h4>
                  {!isEditingPrompt ? (
                    <button
                      onClick={() => setIsEditingPrompt(true)}
                      className="inline-flex items-center px-2 py-1 border border-gray-300 shadow-sm text-xs font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-1 focus:ring-offset-1 focus:ring-indigo-500"
                    >
                      <svg className="h-4 w-4 mr-1" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" />
                      </svg>
                      Edit Prompt
                    </button>
                  ) : (
                    <div className="flex space-x-2">
                      <button
                        onClick={handleSavePrompt}
                        className="inline-flex items-center px-2 py-1 border border-transparent text-xs font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-1 focus:ring-offset-1 focus:ring-indigo-500"
                      >
                        Save
                      </button>
                      <button
                        onClick={handleCancelEdit}
                        className="inline-flex items-center px-2 py-1 border border-gray-300 shadow-sm text-xs font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-1 focus:ring-offset-1 focus:ring-indigo-500"
                      >
                        Cancel
                      </button>
                    </div>
                  )}
                </div>
                <div className="bg-gray-50 p-4 rounded-md">
                  {isEditingPrompt ? (
                    <textarea
                      value={editedPrompt}
                      onChange={(e) => setEditedPrompt(e.target.value)}
                      className="w-full h-64 p-2 text-sm font-mono border border-gray-300 rounded-md focus:ring-indigo-500 focus:border-indigo-500"
                      placeholder="Edit your prompt here..."
                    />
                  ) : (
                    <div className="prose prose-sm max-w-none overflow-y-auto" style={{ maxHeight: "300px" }}>
                      {renderMarkdown(generatedPrompt)}
                    </div>
                  )}
                </div>
              </div>
            </motion.div>
          )}
        </AnimatePresence>

        {/* Rule Content */}
        <div className="px-4 py-5 sm:p-6">
          {rules.length === 0 ? (
            <div className="text-center py-12">
              <svg className="mx-auto h-12 w-12 text-gray-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
              </svg>
              <h3 className="mt-2 text-sm font-medium text-gray-900">No rules generated yet</h3>
              <p className="mt-1 text-sm text-gray-500">
                Click the "Generate Rule" button to create your first rule.
              </p>
            </div>
          ) : !isRuleComplete ? (
            <div className="text-center py-12">
              <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-indigo-600 mx-auto"></div>
              <h3 className="mt-2 text-sm font-medium text-gray-900">Generating rule...</h3>
              <p className="mt-1 text-sm text-gray-500">
                This may take a few moments to complete.
              </p>
            </div>
          ) : error ? (
            <div className="text-center py-12">
              <svg className="mx-auto h-12 w-12 text-red-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
              </svg>
              <h3 className="mt-2 text-sm font-medium text-red-900">Error</h3>
              <p className="mt-1 text-sm text-red-500">
                {error}
              </p>
            </div>
          ) : (
            <div className="prose prose-sm max-w-none max-h-96 overflow-y-auto pr-2 relative">
              {/* Floating Select All Code Blocks button */}
              {rules.length > 0 && isRuleComplete && !error && (
                <button
                  onClick={() => {
                    // Check if we already have all code blocks selected
                    const allBlocksSelected = selectedRules.length > 0 && 
                      currentRule?.rule && 
                      selectedRules.every(rule => rule.id === currentRule.id);
                    
                    if (allBlocksSelected) {
                      // Deselect all blocks
                      setSelectedRules([]);
                    } else {
                      // Extract and select all code blocks
                      const extractedCodeBlocks = [];
                      if (currentRule?.rule) {
                        // Extract all code blocks from the rule content
                        const ruleContent = currentRule.rule;
                        const codeBlockRegex = /```(?:\w*\n)?([\s\S]*?)```/g;
                        let match;
                        
                        // Find all code blocks
                        while ((match = codeBlockRegex.exec(ruleContent)) !== null) {
                          // The actual code content is in the first capturing group
                          const codeBlockText = match[1].trim();
                          
                          // Create a simple hash for the code block
                          const hashCode = str => {
                            let hash = 0;
                            for (let i = 0; i < str.length; i++) {
                              const char = str.charCodeAt(i);
                              hash = ((hash << 5) - hash) + char;
                              hash = hash & hash; // Convert to 32bit integer
                            }
                            return Math.abs(hash).toString(16);
                          };
                          
                          const blockId = `${currentRule.id}-${hashCode(codeBlockText.substring(0, 50))}`;
                          
                          // Add this code block to the list
                          extractedCodeBlocks.push({
                            ...currentRule,
                            blockId,
                            codeBlockText,
                            rule: `\`\`\`\n${codeBlockText}\n\`\`\``,
                            selected: true
                          });
                        }
                        
                        // Set the selected rules
                        setSelectedRules(extractedCodeBlocks);
                      }
                    }
                  }}
                  className={`absolute top-4 right-4 z-10 flex items-center justify-center w-10 h-10 rounded-md shadow-lg focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 ${
                    selectedRules.length > 0 && 
                    currentRule?.rule && 
                    selectedRules.every(rule => rule.id === currentRule.id)
                      ? 'text-white bg-indigo-600 hover:bg-indigo-700' 
                      : 'text-gray-700 bg-white hover:bg-gray-50'
                  }`}
                  title={selectedRules.length > 0 && 
                         currentRule?.rule && 
                         selectedRules.every(rule => rule.id === currentRule.id) 
                         ? "Deselect All Code Blocks" : "Select All Code Blocks"}
                >
                  <svg xmlns="http://www.w3.org/2000/svg" className={`h-5 w-5 ${
                    selectedRules.length > 0 && 
                    currentRule?.rule && 
                    selectedRules.every(rule => rule.id === currentRule.id)
                      ? 'text-white' 
                      : 'text-gray-700'
                  }`} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
                    <path strokeLinecap="round" strokeLinejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" />
                  </svg>
                </button>
              )}
              {renderMarkdown(currentRule.rule)}
            </div>
          )}
        </div>

        {/* Pagination controls */}
        {rules.length > 1 && (
          <div className="px-4 py-3 bg-gray-50 text-right sm:px-6 flex justify-between items-center">
            <div className="flex space-x-2">
              <button
                onClick={() => onRuleIndexChange(rules.length - 1)}
                disabled={currentRuleIndex === rules.length - 1}
                className={`inline-flex items-center px-2 py-1 border border-gray-300 shadow-sm text-xs font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-1 focus:ring-offset-1 focus:ring-indigo-500 ${currentRuleIndex === rules.length - 1 ? 'opacity-50 cursor-not-allowed' : ''
                  }`}
              >
                <svg className="h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 19l-7-7 7-7m8 14l-7-7 7-7" />
                </svg>
              </button>
              <button
                onClick={() => onRuleIndexChange(currentRuleIndex + 1)}
                disabled={currentRuleIndex === rules.length - 1}
                className={`inline-flex items-center px-2 py-1 border border-gray-300 shadow-sm text-xs font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-1 focus:ring-offset-1 focus:ring-indigo-500 ${currentRuleIndex === rules.length - 1 ? 'opacity-50 cursor-not-allowed' : ''
                  }`}
              >
                <svg className="h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
                </svg>
              </button>
            </div>

            <span className="text-sm text-gray-700">
              Rule {rules.length - currentRuleIndex} of {rules.length}
            </span>

            <div className="flex space-x-2">
              <button
                onClick={() => onRuleIndexChange(currentRuleIndex - 1)}
                disabled={currentRuleIndex === 0}
                className={`inline-flex items-center px-2 py-1 border border-gray-300 shadow-sm text-xs font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-1 focus:ring-offset-1 focus:ring-indigo-500 ${currentRuleIndex === 0 ? 'opacity-50 cursor-not-allowed' : ''
                  }`}
              >
                <svg className="h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
                </svg>
              </button>
              <button
                onClick={() => onRuleIndexChange(0)}
                disabled={currentRuleIndex === 0}
                className={`inline-flex items-center px-2 py-1 border border-gray-300 shadow-sm text-xs font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-1 focus:ring-offset-1 focus:ring-indigo-500 ${currentRuleIndex === 0 ? 'opacity-50 cursor-not-allowed' : ''
                  }`}
              >
                <svg className="h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 5l7 7-7 7M5 5l7 7-7 7" />
                </svg>
              </button>
            </div>
          </div>
        )}
      </div>

      {/* Simplified Feedback Section with small textarea and send icon */}
      {rules.length > 0 && isRuleComplete && !error && (
        <div className="mb-6">
          <div className="relative">
            <textarea
              value={feedbackText}
              onChange={(e) => setFeedbackText(e.target.value)}
              rows="3"
              className="w-full p-2 pr-10 text-sm border border-gray-300 rounded-md focus:ring-indigo-500 focus:border-indigo-500"
              placeholder="Provide feedback for rule improvement..."
            />
            <button
              type="button"
              onClick={handleRegenerateWithFeedback}
              disabled={isGenerating || !feedbackText.trim()}
              className={`absolute right-2 bottom-2 p-1 rounded-full text-indigo-600 hover:bg-indigo-100 focus:outline-none ${(isGenerating || !feedbackText.trim()) ? 'opacity-50 cursor-not-allowed' : ''
                }`}
              title="Send feedback and regenerate rule"
            >
              {isGenerating ? (
                <svg className="animate-spin h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                  <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                  <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
              ) : (
                <svg className="h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" />
                </svg>
              )}
            </button>
          </div>
        </div>
      )}

      <div className="mt-6 flex justify-between">
        <button
          type="button"
          onClick={onBack}
          className="inline-flex items-center px-4 py-2 border border-gray-300 shadow-sm text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
        >
          <svg className="mr-2 -ml-1 h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
          </svg>
          Back to Prompt Configuration
        </button>

        <button
          type="button"
          onClick={onGenerateRule}
          disabled={isGenerating}
          className={`inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 ${isGenerating ? 'opacity-50 cursor-not-allowed' : ''
            }`}
        >
          {isGenerating ? (
            <>
              <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
              </svg>
              Generating...
            </>
          ) : (
            <>
              {rules.length > 0 ? 'Regenerate Rule' : 'Generate Rule'}
            </>
          )}
        </button>
      </div>

      {/* Download Modal */}
      <DownloadModal
        isOpen={showDownloadModal}
        onClose={() => setShowDownloadModal(false)}
        onDownload={handleDownload}
      />

      {/* Export Modal */}
      <ExportModal
        isOpen={showExportModal}
        onClose={() => setShowExportModal(false)}
        exportedRules={selectedRules}
        workspace={workspace}
      />
    </div>
  );
};

export default RuleViewer;
